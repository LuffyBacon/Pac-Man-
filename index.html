<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pac‑Man — HTML5 (Arcade AI + Scaling)</title>
  <style>
    :root{
      --bg:#0b0f1a; --panel:#0e1424; --text:#e7f0ff; --accent:#ffd54a;
      --ghost-red:#ff4b4b; --ghost-pink:#ff79c6; --ghost-cyan:#6be7ff; --ghost-orange:#ffb366;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 600px at 10% -10%,#1b2545 0,#0b0f1a 40%,#080b14 100%);color:var(--text);font-family:system-ui,Segoe UI,Inter,Roboto,Arial,sans-serif;display:grid;place-items:center}
    .glow-frame{position:relative;border-radius:20px;padding:18px;background:var(--panel);box-shadow:0 20px 60px rgba(0,0,0,.5),inset 0 0 0 1px rgba(255,255,255,.05);max-width:1200px;width:96vw}
    .glow-frame:before{content:"";position:absolute;inset:-3px;border-radius:22px;filter:blur(8px);z-index:-1;background:conic-gradient(from 0deg,#ff4b4b,#ff7b00,#ffd54a,#69ff89,#6be7ff,#8a71ff,#ff79c6,#ff4b4b);animation:spin 14s linear infinite}
    @keyframes spin{to{transform:rotate(1turn)}}

    #app{display:grid;grid-template-rows:auto 1fr auto;gap:12px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .badge{padding:.35rem .6rem;border-radius:999px;background:linear-gradient(90deg,#ffd54a,#ff79c6,#6be7ff,#ffd54a);background-size:300% 100%;animation:badge 6s linear infinite;color:#121212;font-weight:700}
    @keyframes badge{0%{background-position:0 0}100%{background-position:300% 0}}
    .btn{cursor:pointer;user-select:none;padding:.8rem 1.2rem;border:none;border-radius:12px;font-weight:700;letter-spacing:.3px;background:#111a34;color:var(--text);box-shadow:inset 0 0 0 1px rgba(255,255,255,.06),0 10px 30px rgba(0,0,0,.3);transition:transform .06s ease,filter .2s ease,background .2s ease}
    .btn:hover{filter:brightness(1.1)}.btn:active{transform:translateY(1px)}.btn.primary{background:linear-gradient(90deg,#ffd54a,#ff79c6,#6be7ff);color:#10131b}
    .row{display:flex;gap:10px;align-items:center}
    .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0a0f1f;padding:.18rem .45rem;border-radius:6px;border:1px solid rgba(255,255,255,.06)}

    #front,#modeSelect,#gamePane{display:none}
    #front.active,#modeSelect.active,#gamePane.active{display:grid}

    #front{grid-template-columns:1.1fr .9fr;gap:16px}
    #pitch{padding:18px;border-radius:16px;background:linear-gradient(180deg,#0d1330,#0b1026 40%,#0a0d1e);box-shadow:inset 0 0 0 1px rgba(255,255,255,.05)}
    .title{font-size:1.9rem;font-weight:900;margin:0 0 .25rem}
    .subtitle{margin:.2rem 0 1rem 0;opacity:.85}
    .pill{display:inline-flex;align-items:center;gap:.4rem;padding:.35rem .6rem;border-radius:999px;background:#0a1024;border:1px solid rgba(255,255,255,.06);margin:.2rem .3rem .2rem 0}
    .poster{position:relative;border-radius:16px;overflow:hidden;background:#05070f;display:grid;place-items:center}
    .poster canvas{filter:drop-shadow(0 0 8px #00f8ff)}

    #modeSelect{gap:12px}
    #modes{display:grid;grid-template-columns:repeat(2,1fr);gap:12px}
    .modeCard{padding:16px;border-radius:14px;background:linear-gradient(180deg,#0c1228,#0a0f20);border:1px solid rgba(255,255,255,.06)}

    #hud{display:flex;align-items:center;justify-content:space-between;gap:10px}
    #hud .stats{display:flex;gap:16px;align-items:center}

    #canvasWrap{display:grid;grid-template-columns:1fr 280px;gap:14px;align-items:start}
    #game{background:#000814;border-radius:12px;overflow:hidden;box-shadow:inset 0 0 0 1px rgba(255,255,255,.04);width:100%;height:auto;image-rendering:pixelated}
    #sidebar{padding:12px;border-radius:12px;background:#0b0f1d;border:1px solid rgba(255,255,255,.06)}
    #log{height:240px;overflow:auto;font-size:.9rem;background:#080c17;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.06)}

    /* Touch controls */
    #touch{position:absolute;inset:auto 0 10px 0;display:none;justify-content:center;gap:14px;pointer-events:none}
    .tp{pointer-events:auto;user-select:none;width:64px;height:64px;border-radius:16px;background:#0c1430;border:1px solid rgba(255,255,255,.08);display:grid;place-items:center;font-weight:800}
    .tp:active{transform:translateY(1px)}
    @media (max-width: 1020px){ #canvasWrap{grid-template-columns:1fr} #sidebar{order:-1} #touch{display:flex} }
  </style>
</head>
<body>
  <div id="app" class="glow-frame">
    <header>
      <div class="row">
        <span class="badge">PAC‑MAN — HTML5</span>
        <span>Arrows to move · <span class="kbd">M</span> mute · <span class="kbd">P</span> pause</span>
      </div>
      <div class="row">
        <button id="btnFront" class="btn">Home</button>
        <button id="btnModes" class="btn">Modes</button>
        <button id="btnStart" class="btn primary">Play</button>
      </div>
    </header>

    <section id="front" class="active" aria-label="Front page">
      <div id="pitch">
        <h2 class="title">Chomp the maze. Dodge the ghosts.</h2>
        <p class="subtitle">
          <strong>Pac‑Man</strong> is an action maze chase video game where the player controls the titular character to eat all the dots in a maze while avoiding four ghosts: Blinky, Pinky, Inky, and Clyde. Eating <em>Power Pellets</em> turns the ghosts blue and edible, temporarily reversing the predator‑prey roles, and short cutscenes appear between levels. The game, developed by Namco, is known for its nonviolent gameplay and has become a cultural icon, spawning sequels and merchandise.
        </p>
        <p class="subtitle"><strong>Objective:</strong> Eat all the dots in the maze to advance to the next level.</p>
        <ul>
          <li><strong>Pac‑Man:</strong> The player‑controlled character, a yellow circle with a large appetite.</li>
          <li><strong>The Ghosts:</strong> Blinky (red), Pinky (pink), Inky (cyan), and Clyde (orange) who chase Pac‑Man.</li>
          <li><strong>Gameplay:</strong> Navigate the maze, eat dots/fruit, use Power Pellets to chomp ghosts. Difficulty increases by level.</li>
          <li><strong>Origin & Legacy:</strong> Developed by Toru Iwatani for Namco in 1979 (Puck‑Man). U.S. release in 1980 made it a global icon and the mascot of Bandai Namco.</li>
        </ul>
        <div class="row" style="margin-top:12px">
          <button class="btn primary" id="frontPlay">Play</button>
          <button class="btn" id="frontModes">Choose Mode</button>
        </div>
      </div>
      <div class="poster">
        <canvas id="posterCanvas" width="480" height="480" aria-hidden="true"></canvas>
      </div>
    </section>

    <section id="modeSelect" aria-label="Mode Select">
      <div class="row" style="justify-content:space-between; align-items:end">
        <div>
          <h2 class="title" style="margin-bottom:.35rem">Select a Game Mode</h2>
          <div class="subtitle">Pick your vibe, then hit Play.</div>
        </div>
        <button id="modePlay" class="btn primary">Play</button>
      </div>
      <div id="modes">
        <article class="modeCard"><h3>Classic</h3><p>The classic Pac‑Man game features only one core gameplay mode; the single objective is consistent throughout.</p><button class="btn" data-mode="classic">Choose Classic</button></article>
        <article class="modeCard"><h3>Turbo</h3><p>Turbo increases the overall speed beyond arcade specs for Pac‑Man and ghosts.</p><button class="btn" data-mode="turbo">Choose Turbo</button></article>
        <article class="modeCard"><h3>Hardcore</h3><p>Hardcore significantly increases difficulty and removes safety nets; fail and you’re out.</p><button class="btn" data-mode="hardcore">Choose Hardcore</button></article>
        <article class="modeCard"><h3>Practice</h3><p>Normal gameplay with infinite lives; designed to help newer players improve.</p><button class="btn" data-mode="practice">Choose Practice</button></article>
      </div>
    </section>

    <section id="gamePane" aria-label="Game">
      <div id="hud">
        <div class="stats">
          <div>Mode: <strong id="hudMode">Classic</strong></div>
          <div>Score: <strong id="hudScore">0</strong></div>
          <div>High: <strong id="hudHigh">0</strong></div>
          <div>Lives: <strong id="hudLives">3</strong></div>
          <div>Level: <strong id="hudLevel">1</strong></div>
        </div>
        <div class="row">
          <button id="btnPause" class="btn">Pause (P)</button>
          <button id="btnMute" class="btn">Mute (M)</button>
          <button id="btnReset" class="btn">Reset</button>
        </div>
      </div>
      <div id="canvasWrap" style="position:relative">
        <canvas id="game" width="672" height="744" aria-label="Pac‑Man game canvas"></canvas>
        <div id="touch">
          <button class="tp" data-d="up">↑</button>
          <div class="row" style="gap:8px">
            <button class="tp" data-d="left">←</button>
            <button class="tp" data-d="down">↓</button>
            <button class="tp" data-d="right">→</button>
          </div>
        </div>
        <aside id="sidebar">
          <h3 style="margin:.2rem 0 .6rem 0">How to Play</h3>
          <ul style="margin:.2rem 0 1rem 1rem; line-height:1.5">
            <li>Use arrow keys or on‑screen arrows to move.</li>
            <li>Eat all dots to beat the level. Fruit appears for bonus points.</li>
            <li>Power Pellets turn ghosts blue — chomp them for big points!</li>
            <li>Press a different direction when bumping a wall to turn instantly.</li>
          </ul>
          <h4 style="margin:.9rem 0 .4rem">Event Log</h4>
          <div id="log"></div>
        </aside>
      </div>
    </section>

    <footer>Canvas + WebAudio. Educational homage with arcade‑style AI. No external assets.</footer>
  </div>

  <script>
  // ---------- Helpers / UI ----------
  const $ = s => document.querySelector(s);
  const log = (m)=>{ const el=document.createElement('div'); el.textContent=m; const box=$('#log'); box.appendChild(el); box.scrollTop=box.scrollHeight; };
  const screens={front:$('#front'),modes:$('#modeSelect'),game:$('#gamePane')};
  function show(id){ Object.values(screens).forEach(s=>s.classList.remove('active')); screens[id].classList.add('active'); }

  // ---------- Modes ----------
  const MODES={
    classic : {name:'Classic',  lives:3,  speed:1.00, ghostSpeed:0.95, frightTime:6.0,  fruitScore:100, infinite:false},
    turbo   : {name:'Turbo',    lives:3,  speed:1.35, ghostSpeed:1.25, frightTime:4.0,  fruitScore:150, infinite:false},
    hardcore: {name:'Hardcore', lives:1,  speed:1.05, ghostSpeed:1.30, frightTime:2.4,  fruitScore:200, infinite:false},
    practice: {name:'Practice', lives:99, speed:1.00, ghostSpeed:0.95, frightTime:6.5,  fruitScore:100, infinite:true},
  };
  let state={mode:'classic',score:0,high:Number(localStorage.getItem('pac_hi')||0),lives:3,level:1,dotsLeft:0,running:false,muted:false};

  // ---------- Audio ----------
  const Audio=(()=>{ const ctx=new (window.AudioContext||window.webkitAudioContext)(); const master=ctx.createGain(); master.gain.value=.38; master.connect(ctx.destination);
    function tone(f=440,d=.08,t='square',v=.25){ const o=ctx.createOscillator(), g=ctx.createGain(); o.type=t; o.frequency.value=f; g.gain.value=v; o.connect(g); g.connect(master); const n=ctx.currentTime; g.gain.setValueAtTime(v,n); g.gain.exponentialRampToValueAtTime(.001,n+d); o.start(); o.stop(n+d); }
    let bg=null,run=false,gg=ctx.createGain(); gg.gain.value=.14; gg.connect(master);
    function startBGM(){ if(run) return; run=true; let step=0; bg=setInterval(()=>{ if(state.muted) return; const base=196; const freqs=[0,2,5,7,9,12,14].map(s=>base*Math.pow(2,s/12)); const f=freqs[step%freqs.length]; const o=ctx.createOscillator(), g=ctx.createGain(); o.type='triangle'; o.frequency.value=f; g.gain.value=.12; o.connect(g); g.connect(gg); const n=ctx.currentTime; g.gain.setValueAtTime(.12,n); g.gain.exponentialRampToValueAtTime(.0001,n+.18); o.start(); o.stop(n+.22); step++; }, 240);} 
    function stopBGM(){ if(bg){clearInterval(bg); bg=null;} run=false; }
    return { waka(){ if(!state.muted) tone(820,.05,'square',.12); }, power(){ if(!state.muted) tone(240,.22,'sawtooth',.25); }, eatGhost(){ if(!state.muted) tone(130,.18,'square',.35); }, fruit(){ if(!state.muted) tone(660,.14,'sawtooth',.25); }, death(){ if(!state.muted){ tone(300,.3,'sawtooth',.35); setTimeout(()=>tone(200,.3,'sawtooth',.35),120);} }, startBGM, stopBGM, setMuted:v=>state.muted=v };
  })();

  // ---------- Maze ----------
  const TILE=24, ROWS=31, COLS=28; // 28x31 classic grid
  const START={pac:{x:13,y:23}, ghosts:[{x:13,y:14},{x:14,y:14},{x:12,y:14},{x:15,y:14}]};
  const tunnelRow=14; // middle corridor wraps
  // 0=wall, 1=dot, 2=power, 3=empty, 4=gate
  const MAZE=[
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1,0],
    [0,2,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,2,0],
    [0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0],
    [0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,1,0],
    [0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0],
    [0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0],
    [0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0],
    [0,0,0,0,0,1,0,0,0,1,0,0,0,4,0,0,0,1,0,0,0,1,0,1,0,0,0,0],
    [0,1,1,1,1,1,1,1,0,1,1,1,0,3,0,1,1,1,0,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,1,0,1,0,1,0,1,0,3,0,1,0,1,0,1,0,1,0,0,0,1,0,0],
    [0,1,1,1,0,1,0,1,1,1,1,1,0,3,0,1,1,1,1,1,0,1,0,1,1,1,1,0],
    [0,0,0,1,0,1,0,0,0,0,0,1,0,3,0,1,0,0,0,0,0,1,0,1,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,0,1,1,3,1,1,1,1,0,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,1,0,0,0,1,0,1,0,3,0,1,0,1,0,1,0,0,0,1,0,0,1,0],
    [0,2,1,1,0,1,1,1,0,1,1,1,0,3,0,1,1,1,0,1,1,1,0,1,1,1,2,0],
    [0,1,0,1,0,0,0,1,0,0,0,1,0,3,0,1,0,1,0,0,0,1,0,1,0,1,0,0],
    [0,1,1,1,1,1,0,1,1,1,0,1,1,3,1,1,1,1,0,1,1,1,0,1,1,1,1,0],
    [0,0,0,0,0,1,0,0,0,1,0,0,0,4,0,0,0,1,0,0,0,1,0,1,0,0,0,0],
    [0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0],
    [0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,0],
    [0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0],
    [0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,1,0],
    [0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0],
    [0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0],
    [0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  ];
  function countDots(){ let c=0; for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(MAZE[y][x]===1||MAZE[y][x]===2) c++; return c; }

  // ---------- Entities / Physics ----------
  const DIRS={left:{x:-1,y:0}, right:{x:1,y:0}, up:{x:0,y:-1}, down:{x:0,y:1}};
  const OPP={left:'right', right:'left', up:'down', down:'up'};
  function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

  function isWalkable(x,y){ if(y<0||y>=ROWS) return false; const nx=(x+COLS)%COLS; const cell=MAZE[y][nx]; return cell!==0 && cell!==4; }
  function atCenter(a){ return a.offsetX===0 && a.offsetY===0; }
  function stepTile(entity, dir){ const d=DIRS[dir]; let nx=entity.x+d.x, ny=entity.y+d.y; if(ny===tunnelRow){ nx=(nx+COLS)%COLS; } if(!isWalkable(nx,ny)) return false; entity.x=nx; entity.y=ny; return true; }

  class Actor{ constructor(x,y,spd){ this.x=x; this.y=y; this.dir='left'; this.offsetX=0; this.offsetY=0; this.speed=spd; } }
  class Pacman extends Actor{ constructor(){ super(START.pac.x,START.pac.y,6); } }
  class Ghost extends Actor{ constructor(id,color,start){ super(start.x,start.y,5.2); this.id=id; this.color=color; this.fright=0; this.scatterTarget = ({blinky:{x:COLS-2,y:1}, pinky:{x:1,y:1}, inky:{x:COLS-2,y:ROWS-2}, clyde:{x:1,y:ROWS-2}})[id]; } }

  const canvas=$('#game'), ctx=canvas.getContext('2d');
  const poster=$('#posterCanvas'), pctx=poster.getContext('2d');
  let pac, ghosts=[], input='left', paused=false, last=0, fruit=null, fruitEaten=false;

  function resetEntities(){ const cfg=MODES[state.mode]; pac=new Pacman(); pac.speed=6*cfg.speed; pac.dir='left'; pac.offsetX=pac.offsetY=0; ghosts=[ new Ghost('blinky',getCSS('--ghost-red'),START.ghosts[0]), new Ghost('pinky',getCSS('--ghost-pink'),START.ghosts[1]), new Ghost('inky',getCSS('--ghost-cyan'),START.ghosts[2]), new Ghost('clyde',getCSS('--ghost-orange'),START.ghosts[3]) ]; ghosts.forEach(g=>{ g.speed=5.2*cfg.ghostSpeed; g.offsetX=g.offsetY=0; g.dir='left'; }); fruit=null; fruitEaten=false; }
  function resetGame(){ const cfg=MODES[state.mode]; state.score=0; state.level=1; state.lives=cfg.lives; state.dotsLeft=countDots(); resetEntities(); updateHUD(); log(`Mode: ${cfg.name}`); }
  function updateHUD(){ $('#hudMode').textContent=MODES[state.mode].name; $('#hudScore').textContent=state.score; $('#hudLives').textContent= state.lives===99?'∞':state.lives; $('#hudLevel').textContent=state.level; $('#hudHigh').textContent=state.high; }

  // ---------- Input (keys + touch) ----------
  window.addEventListener('keydown',e=>{ if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','KeyP','KeyM'].includes(e.code)) e.preventDefault(); if(e.code==='ArrowLeft') input='left'; if(e.code==='ArrowRight') input='right'; if(e.code==='ArrowUp') input='up'; if(e.code==='ArrowDown') input='down'; if(e.code==='KeyP'){ paused=!paused; log(paused?'Paused':'Resumed'); } if(e.code==='KeyM'){ state.muted=!state.muted; Audio.setMuted(state.muted); $('#btnMute').textContent=state.muted?'Unmute (M)':'Mute (M)'; } });
  document.querySelectorAll('#touch .tp').forEach(b=> b.addEventListener('click',()=>{ input=b.dataset.d; }));

  // ---------- Eating / Fruit ----------
  function eatAt(x,y){ const t=MAZE[y][(x+COLS)%COLS]; if(t===1){ MAZE[y][x]=3; state.score+=10; state.dotsLeft--; Audio.waka(); } else if(t===2){ MAZE[y][x]=3; state.score+=50; state.dotsLeft--; ghosts.forEach(g=> g.fright=MODES[state.mode].frightTime); Audio.power(); } }
  function maybeFruit(){ if(fruit||fruitEaten) return; const total=countDots(); if(state.dotsLeft<=Math.floor(total*0.5)){ fruit={x:0,y:tunnelRow,ttl:12}; } }

  // ---------- Ghost Targeting (Authentic‑ish) ----------
  const dist=(ax,ay,bx,by)=> Math.abs(ax-bx)+Math.abs(ay-by);
  function ahead(tiles){ const d=DIRS[pac.dir]||{x:0,y:0}; return {x:(pac.x + tiles*d.x + COLS)%COLS, y:pac.y + tiles*d.y}; }
  function targetPinky(){ return pac.dir==='up' ? {x:(pac.x-4+COLS)%COLS, y:pac.y-4} : ahead(4); }
  function targetInky(){ const two=ahead(2); const blinky=ghosts.find(g=>g.id==='blinky'); const vx=(two.x - blinky.x + COLS)%COLS; const vy=two.y - blinky.y; return {x:(blinky.x + 2*vx + COLS)%COLS, y: blinky.y + 2*vy}; }
  function targetClyde(g){ return dist(g.x,g.y,pac.x,pac.y)>=8? {x:pac.x,y:pac.y} : g.scatterTarget; }
  function chooseDir(g){ const opts=['up','left','down','right'].filter(d=> d!==OPP[g.dir] && isWalkable(g.x+DIRS[d].x,g.y+DIRS[d].y)); if(opts.length===0){ const back=OPP[g.dir]; return isWalkable(g.x+DIRS[back].x,g.y+DIRS[back].y)? back : g.dir; } if(g.fright>0){ let far=opts[0], best=-1; for(const d of opts){ const nx=(g.x+DIRS[d].x+COLS)%COLS, ny=g.y+DIRS[d].y; const dd=dist(nx,ny,pac.x,pac.y); if(dd>best){ best=dd; far=d; } } return far; } const t=(performance.now()/1000)%14; const scatter=(t>9); let target=g.scatterTarget; if(!scatter){ if(g.id==='blinky') target={x:pac.x,y:pac.y}; else if(g.id==='pinky') target=targetPinky(); else if(g.id==='inky') target=targetInky(); else if(g.id==='clyde') target=targetClyde(g); } let best=opts[0], bd=1e9; for(const d of opts){ const nx=(g.x+DIRS[d].x+COLS)%COLS, ny=g.y+DIRS[d].y; const dd=dist(nx,ny,target.x,target.y); if(dd<bd){ bd=dd; best=d; } } return best; }

  // ---------- Update ----------
  function update(dt){ if(paused||!state.running) return;
    // Pac‑Man: stop at walls; allow instant turn if new dir is open
    if(atCenter(pac)){
      if(isWalkable(pac.x+(DIRS[input]?.x||0), pac.y+(DIRS[input]?.y||0))) pac.dir=input;
      if(!isWalkable(pac.x+(DIRS[pac.dir]?.x||0), pac.y+(DIRS[pac.dir]?.y||0))) { pac.offsetX=0; pac.offsetY=0; }
    }
    pac.offsetX += (DIRS[pac.dir]?.x||0) * pac.speed * dt;
    pac.offsetY += (DIRS[pac.dir]?.y||0) * pac.speed * dt;
    if(Math.abs(pac.offsetX)>=1){ const s=Math.sign(pac.offsetX); if(stepTile(pac, s>0?'right':'left')){ pac.offsetX-=s; eatAt(pac.x,pac.y);} else { pac.offsetX=0; } }
    if(Math.abs(pac.offsetY)>=1){ const s=Math.sign(pac.offsetY); if(stepTile(pac, s>0?'down':'up')){ pac.offsetY-=s; eatAt(pac.x,pac.y);} else { pac.offsetY=0; } }

    maybeFruit(); if(fruit){ fruit.ttl-=dt; if(fruit.ttl<=0) fruit=null; if(fruit && pac.x===((fruit.x+COLS)%COLS) && pac.y===fruit.y){ state.score+=MODES[state.mode].fruitScore; fruit=null; fruitEaten=true; Audio.fruit(); log('+ Fruit!'); } }

    for(const g of ghosts){ if(g.fright>0) g.fright=Math.max(0,g.fright-dt); if(atCenter(g)) g.dir=chooseDir(g); g.offsetX += (DIRS[g.dir]?.x||0) * g.speed * dt; g.offsetY += (DIRS[g.dir]?.y||0) * g.speed * dt; if(Math.abs(g.offsetX)>=1){ const s=Math.sign(g.offsetX); if(stepTile(g, s>0?'right':'left')) g.offsetX-=s; else g.offsetX=0; } if(Math.abs(g.offsetY)>=1){ const s=Math.sign(g.offsetY); if(stepTile(g, s>0?'down':'up')) g.offsetY-=s; else g.offsetY=0; } if(g.x===pac.x && g.y===pac.y){ if(g.fright>0){ state.score+=200; g.x=START.ghosts[0].x; g.y=START.ghosts[0].y; g.offsetX=g.offsetY=0; g.fright=0; Audio.eatGhost(); log(`Chomped ${g.id}!`); } else { loseLife(); return; } } }

    if(state.dotsLeft<=0) nextLevel(); updateHUD();
  }

  function nextLevel(){ state.level++; const cfg=MODES[state.mode]; cfg.ghostSpeed*=1.03; cfg.speed*=1.02; cfg.frightTime=Math.max(2.0,cfg.frightTime-.4); for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ if(MAZE[y][x]!==0 && MAZE[y][x]!==4) MAZE[y][x]=(Math.random()<0.06?2:1); } state.dotsLeft=countDots(); resetEntities(); updateHUD(); log(`Level ${state.level}!`); }
  function loseLife(){ if(MODES[state.mode].infinite){ Audio.death(); resetEntities(); log('Respawn (practice)'); return; } state.lives--; updateHUD(); Audio.death(); if(state.lives<=0) gameOver(); else { resetEntities(); log('Ouch! -1 life'); } }
  function gameOver(){ state.running=false; paused=true; if(state.score>state.high){ state.high=state.score; localStorage.setItem('pac_hi', String(state.high)); } updateHUD(); log('Game Over'); }

  // ---------- Render ----------
  function drawMaze(){ for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const t=MAZE[y][x]; ctx.fillStyle='#001221'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE); if(t===0){ ctx.fillStyle='#071a3a'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE); ctx.strokeStyle='#0d2b66'; ctx.lineWidth=2; ctx.strokeRect(x*TILE+1,y*TILE+1,TILE-2,TILE-2);} if(t===1){ ctx.fillStyle='#bde3ff'; ctx.beginPath(); ctx.arc(x*TILE+TILE/2,y*TILE+TILE/2,2.2,0,Math.PI*2); ctx.fill(); } if(t===2){ ctx.fillStyle:'#ffd54a'; ctx.beginPath(); ctx.arc(x*TILE+TILE/2,y*TILE+TILE/2,5.0,0,Math.PI*2); ctx.fill(); } } ctx.fillStyle='rgba(255,255,255,.03)'; ctx.fillRect(0,tunnelRow*TILE,COLS*TILE,TILE); }
  function drawPac(){ if(!pac) return; const cx=((pac.x*TILE + TILE/2) + pac.offsetX*TILE), cy=(pac.y*TILE + TILE/2 + pac.offsetY*TILE); const t=(performance.now()/100)%10; const open=Math.abs((t%10)-5)/5*.9; let ang=0; if(pac.dir==='right') ang=0; else if(pac.dir==='left') ang=Math.PI; else if(pac.dir==='up') ang=-Math.PI/2; else ang=Math.PI/2; ctx.fillStyle='#ffd54a'; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,9,ang+open,ang-open,false); ctx.closePath(); ctx.fill(); ctx.shadowColor='#ffd54a'; ctx.shadowBlur=10; ctx.beginPath(); ctx.arc(cx,cy,9,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0; }
  function drawGhost(g){ const cx=((g.x*TILE + TILE/2) + g.offsetX*TILE), cy=(g.y*TILE + TILE/2 + g.offsetY*TILE); const color=g.fright>0? '#3aa7ff' : g.color; ctx.fillStyle=color; ctx.beginPath(); ctx.arc(cx,cy-2,8,Math.PI,0); ctx.lineTo(cx+8,cy+6); for(let i=0;i<3;i++){ ctx.lineTo(cx+8-5*i,cy+8); ctx.lineTo(cx+3-5*i,cy+6);} ctx.lineTo(cx-8,cy+6); ctx.closePath(); ctx.fill(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(cx-3,cy-2,2,0,Math.PI*2); ctx.arc(cx+3,cy-2,2,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#112'; const dx=DIRS[g.dir]?.x||0, dy=DIRS[g.dir]?.y||0; ctx.beginPath(); ctx.arc(cx-3+dx,cy-2+dy,1,0,Math.PI*2); ctx.arc(cx+3+dx,cy-2+dy,1,0,Math.PI*2); ctx.fill(); ctx.shadowColor=color; ctx.shadowBlur=12; ctx.fill(); ctx.shadowBlur=0; }
  function drawFruit(){ if(!fruit) return; const cx=((fruit.x+COLS)%COLS)*TILE+TILE/2, cy=fruit.y*TILE+TILE/2; ctx.save(); ctx.translate(cx,cy); ctx.rotate(((performance.now()/500)%360)*Math.PI/180); ctx.fillStyle='#ff5f7e'; ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#33dd66'; ctx.fillRect(-1,-9,2,6); ctx.restore(); }
  function render(){ ctx.clearRect(0,0,canvas.width,canvas.height); drawMaze(); drawFruit(); if(ghosts && Array.isArray(ghosts)) ghosts.forEach(drawGhost); if(pac) drawPac(); }

  // ---------- Loop ----------
  function loop(ts){ const dt=Math.min(.05,(ts-last)/1000||0); last=ts; if(state.running) update(dt); render(); requestAnimationFrame(loop); }

  // ---------- UI wiring ----------
  function selectMode(m){ state.mode=m; const cfg=MODES[m]; state.lives=cfg.lives; $('#hudMode').textContent=cfg.name; log(`Selected ${cfg.name}`); }
  $('#btnFront').onclick=()=>show('front'); $('#btnModes').onclick=()=>show('modes'); $('#btnStart').onclick=()=>{ show('game'); startGame(); };
  $('#frontPlay').onclick=()=>{ show('game'); startGame(); }; $('#frontModes').onclick=()=>show('modes'); $('#modePlay').onclick=()=>{ show('game'); startGame(); };
  document.querySelectorAll('[data-mode]').forEach(b=> b.onclick=()=>selectMode(b.dataset.mode));
  $('#btnPause').onclick=()=>{ paused=!paused; log(paused?'Paused':'Resumed'); };
  $('#btnMute').onclick=()=>{ state.muted=!state.muted; Audio.setMuted(state.muted); $('#btnMute').textContent=state.muted?'Unmute (M)':'Mute (M)'; };
  $('#btnReset').onclick=()=>{ resetGame(); };

  function startGame(){ const cfg=MODES[state.mode]; paused=false; state.running=true; resetGame(); if(!isWalkable(pac.x,pac.y)){ pac.x=START.pac.x; pac.y=START.pac.y; pac.offsetX=pac.offsetY=0; } updateHUD(); Audio.startBGM(); render(); }

  // ---------- Poster ----------
  function drawPoster(){ const w=poster.width,h=poster.height; pctx.clearRect(0,0,w,h); for(let i=0;i<180;i++){ const x=Math.random()*w,y=Math.random()*h; pctx.fillStyle=`hsl(${(performance.now()/30 + i*8)%360} 90% 60%)`; pctx.globalAlpha=.12; pctx.fillRect(x,y,Math.random()*2+1,Math.random()*10+6);} pctx.globalAlpha=1; const t=performance.now()/100; const cx=240, cy=240, R=70; const open=Math.abs(((t%20)-10)/10)*0.9; pctx.fillStyle='#ffd54a'; pctx.beginPath(); pctx.moveTo(cx,cy); pctx.arc(cx,cy,R,-open,open); pctx.closePath(); pctx.fill(); const names=['#ff4b4b','#ff79c6','#6be7ff','#ffb366']; for(let i=0;i<4;i++){ const gx=cx+R+20+i*36, gy=cy; pctx.fillStyle=names[i]; pctx.beginPath(); pctx.arc(gx,gy-10,16,Math.PI,0); pctx.lineTo(gx+16,gy+16); pctx.lineTo(gx-16,gy+16); pctx.closePath(); pctx.fill(); } requestAnimationFrame(drawPoster); }

  // Boot
  updateHUD(); resetEntities(); requestAnimationFrame(loop); requestAnimationFrame(drawPoster);
  $('#btnStart').onclick=()=>{ show('game'); startGame(); };
$('#frontPlay').onclick=()=>{ show('game'); startGame(); };

  </script>
</body>
</html>
